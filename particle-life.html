<html>
<title>Life</title>

<head>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
        :root {
            color-scheme: dark;
            --canvas-bg-color: rgba(0, 0, 0, 0);
            /* transparent */
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #canvas {
            border: #504e52;
            border-style: dashed;
            border-width: 5;
            outline: none;
            /* because of the 'tabindex' focus trick */
            background-color: var(--canvas-bg-color);
        }
    </style>
</head>

<body>
    <canvas id="life" width="500" height="500"></canvas>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17"></script>
    <script>
        //this code is modified verison of https://github.com/hunar4321/particle-life

        m = document.getElementById("life").getContext("2d");

        defaultColorSetting = (i, c, on) => {
            return {
                index: i,
                color: c,
                onOff: on,
                detectionRange: 30,
                deathEvent: "nothing",
                consumeSizeUp: 1,
                sizeLimit: 15,
                canConsume: ["red"],
            }
        }

        settings = {
            Pause: false,
            Speed: 1,
            Gravity: 0.0,
            colors: [
                defaultColorSetting(0, "red", true),
                defaultColorSetting(1, "orange", true),
                defaultColorSetting(2, "yellow", true),
                defaultColorSetting(3, "green", false),
                defaultColorSetting(4, "aqua", false),
                defaultColorSetting(5, "blue", false),
                defaultColorSetting(6, "violet", false),
            ],
            rules: {},
            Random: () => { randomRules() },
            gui: null,
        }

        Object.defineProperty(String.prototype, 'capitalise', {
            value: function () {
                return this.charAt(0).toUpperCase() + this.slice(1);
            },
            enumerable: false
        })

        const setupGUI = () => {
            settings.gui = new lil.GUI();

            //game settings
            const settingGame = settings.gui.addFolder('Game Settings');
            settingGame.add(settings, 'Pause');
            settingGame.add(settings, 'Speed', -10, 10, 0.1).name("Game Speed");
            settingGame.add(settings, 'Gravity', 0, 10, 0.1);
            settingGame.add(settings, 'Random').name("Randomize Rules");

            //particle on/off
            const settingParticleOnOff = settings.gui.addFolder('Particle ON/OFF');
            for (var i = 0; i < settings.colors.length; i++) {
                element = settings.colors[i];

                settingParticleOnOff.add(element, "onOff")
                    .name(`<font color=\'${element.color}\'>${element.color.toUpperCase()}</font>`)
                    .listen().onFinishChange((v) => {
                        foldersOnOff();
                    });
            }

            //particle rules
            const settingParticleRules = settings.gui.addFolder('Particle Rules');
            for (var i of settings.colors) {
                element = i
                i = i.color

                //[color] (folder)
                const folderRule = settingParticleRules
                    .addFolder(i)
                    .title(`<font color=\'${i}\'>[${i}]</font>`)
                    .close();

                //[color] - property
                const folderRuleProperty = folderRule
                    .addFolder(i)
                    .title(`<font color=\'${i}\'>property</font>`)
                    .close();

                folderRuleProperty.add(element, "detectionRange", 10, 300, 1);


                //[color] - strength
                const folderRuleStrength = folderRule
                    .addFolder(i)
                    .title(`<font color=\'${i}\'>strength</font>`)

                for (var j of settings.colors) {
                    j = j.color
                    //[color]<=>[color] (controller)
                    folderRuleStrength.add(settings.rules[i], j, -1, 1)
                        .name(`<font color=\'${i}\'>${i}</font><=><font color=\'${j}\'>${j}</font>`)
                }
            }
            foldersOnOff();

        }

        foldersOnOff = () => {
            for (var i = 0; i < settings.colors.length; i++) {
                element = settings.gui.folders[1].children[i];

                if (element.object.onOff) {
                    settings.gui.folders[2].children[i].show();

                    for (var j = 0; j < settings.colors.length; j++) {
                        element2 = settings.gui.folders[1].children[j];

                        if (element2.object.onOff) {
                            settings.gui.folders[2].children[i].children[1].children[j].show();
                        }
                        else {
                            settings.gui.folders[2].children[i].children[1].children[j].hide();
                        }
                    }
                }
                else {
                    settings.gui.folders[2].children[i].hide();
                }
            }
        }

        randomRules = () => {
            for (const i of settings.colors) {
                settings.rules[i.color] = {};
                for (const j of settings.colors) {
                    settings.rules[i.color][j.color] = Number((Math.random() * 2 - 1).toFixed(3));
                }
            }
        };

        draw = (x, y, c, s, opt = null) => {
            m.fillStyle = c;
            if (!opt) {
                m.fillRect(x, y, s, s);
            }
            else {
                m.fillRect(x, y, s, opt);
            }
        };

        atoms = [];
        atom = (x, y, c, s) => {
            return {
                x: x, y: y,
                vx: 0, vy: 0,
                color: c,
                size: s,
            };
        };

        random = () => {
            return Math.random() * 400 + 50;
        };

        create = (number, color, size) => {
            group = [];
            for (let i = 0; i < number; i++) {
                group.push(atom(random(), random(), color, size));
                atoms.push(group[i]);
            }
            return group;
        };

        rule = (a1, a2, g) => {
            atoms1 = atomSets[a1];
            atoms2 = atomSets[a2]; 
            for (let i = 0; i < atoms1.length; i++) {
                fx = 0;
                fy = 0;
                for (let j = 0; j < atoms2.length; j++) {
                    a = atoms1[i];
                    b = atoms2[j];
                    dx = a.x - b.x;
                    dy = a.y - b.y;
                    d = Math.sqrt(dx * dx + dy * dy);
                    if (d > 0 && d < settings.colors[a1].detectionRange) {
                        F = (g * 1) / d;
                        fx += F * dx;
                        fy += F * dy;
                    }
                }
                a.vx = (a.vx + fx) * 0.5;
                a.vy = (a.vy + fy) * 0.5;
                a.x += a.vx;
                a.y += a.vy;

                //push back in
                if (a.x <= 0) { a.vx = -1 * a.vx + 5; }
                else if (a.x >= canvasSize.x - initSize) { a.vx = -1 * a.vx - 5; }
                else if (a.y <= 0) { a.vy = -1 * a.vy + 5; }
                else if (a.y >= canvasSize.y - initSize) { a.vy = -1 * a.vy - 5; }
            }
        };

        applyRules = () => {
            for (var i = 0; i < settings.colors.length; i++) {
                for (var j = 0; j < settings.colors.length; j++) {
                    if (!settings.colors[i].onOff || !settings.colors[j].onOff) {
                        continue;
                    }
                    rule(i, j, settings.rules[settings.colors[i].color][settings.colors[j].color]);
                }
            }
        }

        //--------------setup start-------------
        randomRules();
        setupGUI();

        const initParticleNum = 50;
        const initSize = 5;
        const canvasSize = { x: 500, y: 500 };

        atomSets = [];
        for (i = 0; i < settings.colors.length; i++) {
            atomSets.push(create(initParticleNum, settings.colors[i].color, initSize));
        }

        update = () => {
            if (!settings.Pause) {
                applyRules();
                m.clearRect(0, 0, 500, 500);
                draw(0, 0, "black", 500);
            }
            else {
                m.clearRect(0, 0, 500, 500);
                draw(0, 0, "darkslategray", 500);
                draw(canvasSize.x / 2 - 10 - 25, canvasSize.y / 2 - 50, "grey", 20, 100);
                draw(canvasSize.x / 2 - 10 + 25, canvasSize.y / 2 - 50, "grey", 20, 100);
            }

            for (i = 0; i < settings.colors.length; i++) {
                if (!settings.colors[i].onOff) { continue; }

                for (j = 0; j < atomSets[i].length; j++) {
                    draw(atomSets[i][j].x, atomSets[i][j].y, atomSets[i][j].color, atomSets[i][j].size);
                }
            }
            requestAnimationFrame(update);
        };

        update();
    </script>

</body>

</html>